'''
GenFoo.py
Generated by MiddleKit.
'''

# MK attribute caches for setFoo() methods
_bAttr = None
_iAttr = None
_lAttr = None
_fAttr = None
_sAttr = None
_dAttr = None
_tAttr = None
_dtAttr = None
_eAttr = None
_barAttr = None


from datetime import date, datetime, time, timedelta
from decimal import Decimal
from MiscUtils.DateParser import parseDateTime, parseDate, parseTime
from MiddleKit.Run.MiddleObject import MiddleObject


from MiddleKit.Run.MiddleObject import MiddleObject
from MiddleKit.Run.SQLObjectStore import ObjRefError



class GenFoo(MiddleObject):

    def __init__(self):
        MiddleObject.__init__(self)
        self._b   = None
        self._i   = None
        self._l   = None
        self._f   = None
        self._s   = None
        self._d   = None
        self._t   = None
        self._dt  = None
        self._e   = None
        self._bar = None


    def b(self):
        return self._b

    def setB(self, value):
        if value is not None:
            if not isinstance(value, (bool, int)):
                raise TypeError('expecting bool or int for bool, but got value %r of type %r instead' % (value, type(value)))
            if value not in (True, False, 1, 0):
                raise ValueError('expecting True, False, 1 or 0 for bool, but got %s instead' % value)

        # set the attribute
        origValue = self._b
        self._b = value

        # MiddleKit machinery
        if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
            global _bAttr
            if _bAttr is None:
                _bAttr = self.klass().lookupAttr('b')
                if not _bAttr.shouldRegisterChanges():
                    _bAttr = 0
            if _bAttr:
                # Record that it has been changed
                self._mk_changed = True
                if self._mk_changedAttrs is None:
                    self._mk_changedAttrs = {}  # maps name to attribute
                self._mk_changedAttrs['b'] = _bAttr  # changedAttrs is a set
                # Tell ObjectStore it happened
                self._mk_store.objectChanged(self)

    def i(self):
        return self._i

    def setI(self, value):
        if value is not None:
            if isinstance(value, int):
                value = int(value)
                #if isinstance(value, int):
                #    raise OverflowError(value)
            elif not isinstance(value, int):
                raise TypeError('expecting int type, but got value %r of type %r instead' % (value, type(value)))

        # set the attribute
        origValue = self._i
        self._i = value

        # MiddleKit machinery
        if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
            global _iAttr
            if _iAttr is None:
                _iAttr = self.klass().lookupAttr('i')
                if not _iAttr.shouldRegisterChanges():
                    _iAttr = 0
            if _iAttr:
                # Record that it has been changed
                self._mk_changed = True
                if self._mk_changedAttrs is None:
                    self._mk_changedAttrs = {}  # maps name to attribute
                self._mk_changedAttrs['i'] = _iAttr  # changedAttrs is a set
                # Tell ObjectStore it happened
                self._mk_store.objectChanged(self)

    def l(self):
        return self._l

    def setL(self, value):
        if value is not None:
            if isinstance(value, int):
                value = int(value)
            elif not isinstance(value, int):
                raise TypeError('expecting int type, but got value %r of type %r instead' % (value, type(value)))

        # set the attribute
        origValue = self._l
        self._l = value

        # MiddleKit machinery
        if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
            global _lAttr
            if _lAttr is None:
                _lAttr = self.klass().lookupAttr('l')
                if not _lAttr.shouldRegisterChanges():
                    _lAttr = 0
            if _lAttr:
                # Record that it has been changed
                self._mk_changed = True
                if self._mk_changedAttrs is None:
                    self._mk_changedAttrs = {}  # maps name to attribute
                self._mk_changedAttrs['l'] = _lAttr  # changedAttrs is a set
                # Tell ObjectStore it happened
                self._mk_store.objectChanged(self)

    def f(self):
        return self._f

    def setF(self, value):
        if value is not None:
            if isinstance(value, int):
                value = float(value)
            elif not isinstance(value, float):
                raise TypeError('expecting float type, but got value %r of type %r instead' % (value, type(value)))

        # set the attribute
        origValue = self._f
        self._f = value

        # MiddleKit machinery
        if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
            global _fAttr
            if _fAttr is None:
                _fAttr = self.klass().lookupAttr('f')
                if not _fAttr.shouldRegisterChanges():
                    _fAttr = 0
            if _fAttr:
                # Record that it has been changed
                self._mk_changed = True
                if self._mk_changedAttrs is None:
                    self._mk_changedAttrs = {}  # maps name to attribute
                self._mk_changedAttrs['f'] = _fAttr  # changedAttrs is a set
                # Tell ObjectStore it happened
                self._mk_store.objectChanged(self)

    def s(self):
        return self._s

    def setS(self, value):
        if value is not None:
            if not isinstance(value, str):
                raise TypeError('expecting string type, but got value %r of type %r instead' % (value, type(value)))

        # set the attribute
        origValue = self._s
        self._s = value

        # MiddleKit machinery
        if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
            global _sAttr
            if _sAttr is None:
                _sAttr = self.klass().lookupAttr('s')
                if not _sAttr.shouldRegisterChanges():
                    _sAttr = 0
            if _sAttr:
                # Record that it has been changed
                self._mk_changed = True
                if self._mk_changedAttrs is None:
                    self._mk_changedAttrs = {}  # maps name to attribute
                self._mk_changedAttrs['s'] = _sAttr  # changedAttrs is a set
                # Tell ObjectStore it happened
                self._mk_store.objectChanged(self)

    def d(self):
        return self._d

    def setD(self, value):
        if isinstance(value, datetime):
            value = value.date()
        if value is not None:
            if isinstance(value, str):
                value = parseDate(value)
            if not isinstance(value, date):
                raise TypeError('expecting date type (e.g., date), but got'
                    ' value %r of type %r instead' % (value, type(value)))

        # set the attribute
        origValue = self._d
        self._d = value

        # MiddleKit machinery
        if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
            global _dAttr
            if _dAttr is None:
                _dAttr = self.klass().lookupAttr('d')
                if not _dAttr.shouldRegisterChanges():
                    _dAttr = 0
            if _dAttr:
                # Record that it has been changed
                self._mk_changed = True
                if self._mk_changedAttrs is None:
                    self._mk_changedAttrs = {}  # maps name to attribute
                self._mk_changedAttrs['d'] = _dAttr  # changedAttrs is a set
                # Tell ObjectStore it happened
                self._mk_store.objectChanged(self)

    def t(self):
        return self._t

    def setT(self, value):
        if isinstance(value, datetime):
            value = value.time()
        if value is not None:
            if isinstance(value, str):
                value = parseTime(value)
            if not isinstance(value, (time, timedelta)):
                raise TypeError('expecting time type (e.g., (time, timedelta)), but got'
                    ' value %r of type %r instead' % (value, type(value)))

        # set the attribute
        origValue = self._t
        self._t = value

        # MiddleKit machinery
        if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
            global _tAttr
            if _tAttr is None:
                _tAttr = self.klass().lookupAttr('t')
                if not _tAttr.shouldRegisterChanges():
                    _tAttr = 0
            if _tAttr:
                # Record that it has been changed
                self._mk_changed = True
                if self._mk_changedAttrs is None:
                    self._mk_changedAttrs = {}  # maps name to attribute
                self._mk_changedAttrs['t'] = _tAttr  # changedAttrs is a set
                # Tell ObjectStore it happened
                self._mk_store.objectChanged(self)

    def dt(self):
        return self._dt

    def setDt(self, value):
        if value is not None:
            if isinstance(value, str):
                value = parseDateTime(value)
            if not isinstance(value, datetime):
                raise TypeError('expecting datetime type (e.g., datetime), but got'
                    ' value %r of type %r instead' % (value, type(value)))

        # set the attribute
        origValue = self._dt
        self._dt = value

        # MiddleKit machinery
        if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
            global _dtAttr
            if _dtAttr is None:
                _dtAttr = self.klass().lookupAttr('dt')
                if not _dtAttr.shouldRegisterChanges():
                    _dtAttr = 0
            if _dtAttr:
                # Record that it has been changed
                self._mk_changed = True
                if self._mk_changedAttrs is None:
                    self._mk_changedAttrs = {}  # maps name to attribute
                self._mk_changedAttrs['dt'] = _dtAttr  # changedAttrs is a set
                # Tell ObjectStore it happened
                self._mk_store.objectChanged(self)

    def e(self):
        return self._e

    def setE(self, value):
        global _eAttr
        if _eAttr is None:
            _eAttr = self.klass().lookupAttr('e')

        if value is not None:
            if not isinstance(value, str):
                raise TypeError('expecting string type for enum, but got value %r of type %r instead' % (value, type(value)))
            attr = self.klass().lookupAttr('e')
            if not attr.hasEnum(value):
                raise ValueError('expecting one of %r, but got %r instead' % (attr.enums(), value))

        # set the attribute
        origValue = self._e
        self._e = value

        # MiddleKit machinery
        if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
            # Record that it has been changed
            self._mk_changed = 1
            if self._mk_changedAttrs is None:
                self._mk_changedAttrs = {}  # maps name to attribute
            self._mk_changedAttrs['e'] = _eAttr  # changedAttrs is a set
            # Tell ObjectStore it happened
            self._mk_store.objectChanged(self)

    def bar(self):
        if self._bar is not None and not isinstance(self._bar, MiddleObject):
            try:
                self.__dict__['_bar'] = self._mk_store.fetchObjRef(self._bar)
            except ObjRefError as e:
                self.__dict__['_bar'] = self.objRefErrorWasRaised(e, 'Foo', 'bar')
        return self._bar

    def setBar(self, value):
        
        if value is not None and not isinstance(value, int):
            if not isinstance(value, MiddleObject):
                raise TypeError('expecting a MiddleObject, but got value %r of type %r instead' % (value, type(value)))
            from Bar import Bar
            if not isinstance(value, Bar):
                raise TypeError('expecting Bar, but got value %r of type %r instead' % (value, type(value)))

        # set the attribute
        origValue = self._bar
        self._bar = value

        # MiddleKit machinery
        if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
            global _barAttr
            if _barAttr is None:
                _barAttr = self.klass().lookupAttr('bar')
                if not _barAttr.shouldRegisterChanges():
                    _barAttr = 0
            if _barAttr:
                # Record that it has been changed
                self._mk_changed = True
                if self._mk_changedAttrs is None:
                    self._mk_changedAttrs = {}  # maps name to attribute
                self._mk_changedAttrs['bar'] = _barAttr  # changedAttrs is a set
                # Tell ObjectStore it happened
                self._mk_store.objectChanged(self)

